// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: response.proto

#ifndef PROTOBUF_response_2eproto__INCLUDED
#define PROTOBUF_response_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_response_2eproto();
void protobuf_AssignDesc_response_2eproto();
void protobuf_ShutdownFile_response_2eproto();

class ResponsePacket;
class FolderStructureResponse;
class FileInformation;
class DownloadInitResponse;
class DownloadDataResponse;
class TestConnectionResponse;
class AddFolderResponse;
class DeleteResourceResponse;

// ===================================================================

class ResponsePacket : public ::google::protobuf::Message {
 public:
  ResponsePacket();
  virtual ~ResponsePacket();

  ResponsePacket(const ResponsePacket& from);

  inline ResponsePacket& operator=(const ResponsePacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePacket& default_instance();

  void Swap(ResponsePacket* other);

  // implements Message ----------------------------------------------

  ResponsePacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponsePacket& from);
  void MergeFrom(const ResponsePacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FolderStructureResponse folderStructureResponse = 1;
  inline bool has_folderstructureresponse() const;
  inline void clear_folderstructureresponse();
  static const int kFolderStructureResponseFieldNumber = 1;
  inline const ::FolderStructureResponse& folderstructureresponse() const;
  inline ::FolderStructureResponse* mutable_folderstructureresponse();
  inline ::FolderStructureResponse* release_folderstructureresponse();
  inline void set_allocated_folderstructureresponse(::FolderStructureResponse* folderstructureresponse);

  // optional .DownloadInitResponse downloadInitResponse = 2;
  inline bool has_downloadinitresponse() const;
  inline void clear_downloadinitresponse();
  static const int kDownloadInitResponseFieldNumber = 2;
  inline const ::DownloadInitResponse& downloadinitresponse() const;
  inline ::DownloadInitResponse* mutable_downloadinitresponse();
  inline ::DownloadInitResponse* release_downloadinitresponse();
  inline void set_allocated_downloadinitresponse(::DownloadInitResponse* downloadinitresponse);

  // optional .DownloadDataResponse downloadDataResponse = 3;
  inline bool has_downloaddataresponse() const;
  inline void clear_downloaddataresponse();
  static const int kDownloadDataResponseFieldNumber = 3;
  inline const ::DownloadDataResponse& downloaddataresponse() const;
  inline ::DownloadDataResponse* mutable_downloaddataresponse();
  inline ::DownloadDataResponse* release_downloaddataresponse();
  inline void set_allocated_downloaddataresponse(::DownloadDataResponse* downloaddataresponse);

  // optional .TestConnectionResponse testConnectionResponse = 4;
  inline bool has_testconnectionresponse() const;
  inline void clear_testconnectionresponse();
  static const int kTestConnectionResponseFieldNumber = 4;
  inline const ::TestConnectionResponse& testconnectionresponse() const;
  inline ::TestConnectionResponse* mutable_testconnectionresponse();
  inline ::TestConnectionResponse* release_testconnectionresponse();
  inline void set_allocated_testconnectionresponse(::TestConnectionResponse* testconnectionresponse);

  // optional .AddFolderResponse addFolderResponse = 5;
  inline bool has_addfolderresponse() const;
  inline void clear_addfolderresponse();
  static const int kAddFolderResponseFieldNumber = 5;
  inline const ::AddFolderResponse& addfolderresponse() const;
  inline ::AddFolderResponse* mutable_addfolderresponse();
  inline ::AddFolderResponse* release_addfolderresponse();
  inline void set_allocated_addfolderresponse(::AddFolderResponse* addfolderresponse);

  // optional .DeleteResourceResponse deleteResourceResponse = 6;
  inline bool has_deleteresourceresponse() const;
  inline void clear_deleteresourceresponse();
  static const int kDeleteResourceResponseFieldNumber = 6;
  inline const ::DeleteResourceResponse& deleteresourceresponse() const;
  inline ::DeleteResourceResponse* mutable_deleteresourceresponse();
  inline ::DeleteResourceResponse* release_deleteresourceresponse();
  inline void set_allocated_deleteresourceresponse(::DeleteResourceResponse* deleteresourceresponse);

  // @@protoc_insertion_point(class_scope:ResponsePacket)
 private:
  inline void set_has_folderstructureresponse();
  inline void clear_has_folderstructureresponse();
  inline void set_has_downloadinitresponse();
  inline void clear_has_downloadinitresponse();
  inline void set_has_downloaddataresponse();
  inline void clear_has_downloaddataresponse();
  inline void set_has_testconnectionresponse();
  inline void clear_has_testconnectionresponse();
  inline void set_has_addfolderresponse();
  inline void clear_has_addfolderresponse();
  inline void set_has_deleteresourceresponse();
  inline void clear_has_deleteresourceresponse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FolderStructureResponse* folderstructureresponse_;
  ::DownloadInitResponse* downloadinitresponse_;
  ::DownloadDataResponse* downloaddataresponse_;
  ::TestConnectionResponse* testconnectionresponse_;
  ::AddFolderResponse* addfolderresponse_;
  ::DeleteResourceResponse* deleteresourceresponse_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static ResponsePacket* default_instance_;
};
// -------------------------------------------------------------------

class FolderStructureResponse : public ::google::protobuf::Message {
 public:
  FolderStructureResponse();
  virtual ~FolderStructureResponse();

  FolderStructureResponse(const FolderStructureResponse& from);

  inline FolderStructureResponse& operator=(const FolderStructureResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FolderStructureResponse& default_instance();

  void Swap(FolderStructureResponse* other);

  // implements Message ----------------------------------------------

  FolderStructureResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FolderStructureResponse& from);
  void MergeFrom(const FolderStructureResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FileInformation fileInformation = 1;
  inline int fileinformation_size() const;
  inline void clear_fileinformation();
  static const int kFileInformationFieldNumber = 1;
  inline const ::FileInformation& fileinformation(int index) const;
  inline ::FileInformation* mutable_fileinformation(int index);
  inline ::FileInformation* add_fileinformation();
  inline const ::google::protobuf::RepeatedPtrField< ::FileInformation >&
      fileinformation() const;
  inline ::google::protobuf::RepeatedPtrField< ::FileInformation >*
      mutable_fileinformation();

  // @@protoc_insertion_point(class_scope:FolderStructureResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::FileInformation > fileinformation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static FolderStructureResponse* default_instance_;
};
// -------------------------------------------------------------------

class FileInformation : public ::google::protobuf::Message {
 public:
  FileInformation();
  virtual ~FileInformation();

  FileInformation(const FileInformation& from);

  inline FileInformation& operator=(const FileInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInformation& default_instance();

  void Swap(FileInformation* other);

  // implements Message ----------------------------------------------

  FileInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileInformation& from);
  void MergeFrom(const FileInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 resourceType = 2;
  inline bool has_resourcetype() const;
  inline void clear_resourcetype();
  static const int kResourceTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 resourcetype() const;
  inline void set_resourcetype(::google::protobuf::uint32 value);

  // optional uint64 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // optional uint64 createTime = 4;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 4;
  inline ::google::protobuf::uint64 createtime() const;
  inline void set_createtime(::google::protobuf::uint64 value);

  // optional uint64 modifiedTime = 5;
  inline bool has_modifiedtime() const;
  inline void clear_modifiedtime();
  static const int kModifiedTimeFieldNumber = 5;
  inline ::google::protobuf::uint64 modifiedtime() const;
  inline void set_modifiedtime(::google::protobuf::uint64 value);

  // optional bool isDirectory = 6;
  inline bool has_isdirectory() const;
  inline void clear_isdirectory();
  static const int kIsDirectoryFieldNumber = 6;
  inline bool isdirectory() const;
  inline void set_isdirectory(bool value);

  // @@protoc_insertion_point(class_scope:FileInformation)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_resourcetype();
  inline void clear_has_resourcetype();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_modifiedtime();
  inline void clear_has_modifiedtime();
  inline void set_has_isdirectory();
  inline void clear_has_isdirectory();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 createtime_;
  ::google::protobuf::uint32 resourcetype_;
  bool isdirectory_;
  ::google::protobuf::uint64 modifiedtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static FileInformation* default_instance_;
};
// -------------------------------------------------------------------

class DownloadInitResponse : public ::google::protobuf::Message {
 public:
  DownloadInitResponse();
  virtual ~DownloadInitResponse();

  DownloadInitResponse(const DownloadInitResponse& from);

  inline DownloadInitResponse& operator=(const DownloadInitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadInitResponse& default_instance();

  void Swap(DownloadInitResponse* other);

  // implements Message ----------------------------------------------

  DownloadInitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadInitResponse& from);
  void MergeFrom(const DownloadInitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .FileInformation fileInformation = 1;
  inline bool has_fileinformation() const;
  inline void clear_fileinformation();
  static const int kFileInformationFieldNumber = 1;
  inline const ::FileInformation& fileinformation() const;
  inline ::FileInformation* mutable_fileinformation();
  inline ::FileInformation* release_fileinformation();
  inline void set_allocated_fileinformation(::FileInformation* fileinformation);

  // @@protoc_insertion_point(class_scope:DownloadInitResponse)
 private:
  inline void set_has_fileinformation();
  inline void clear_has_fileinformation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FileInformation* fileinformation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static DownloadInitResponse* default_instance_;
};
// -------------------------------------------------------------------

class DownloadDataResponse : public ::google::protobuf::Message {
 public:
  DownloadDataResponse();
  virtual ~DownloadDataResponse();

  DownloadDataResponse(const DownloadDataResponse& from);

  inline DownloadDataResponse& operator=(const DownloadDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DownloadDataResponse& default_instance();

  void Swap(DownloadDataResponse* other);

  // implements Message ----------------------------------------------

  DownloadDataResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DownloadDataResponse& from);
  void MergeFrom(const DownloadDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:DownloadDataResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static DownloadDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class TestConnectionResponse : public ::google::protobuf::Message {
 public:
  TestConnectionResponse();
  virtual ~TestConnectionResponse();

  TestConnectionResponse(const TestConnectionResponse& from);

  inline TestConnectionResponse& operator=(const TestConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConnectionResponse& default_instance();

  void Swap(TestConnectionResponse* other);

  // implements Message ----------------------------------------------

  TestConnectionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestConnectionResponse& from);
  void MergeFrom(const TestConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .FileInformation fileInformation = 1;
  inline bool has_fileinformation() const;
  inline void clear_fileinformation();
  static const int kFileInformationFieldNumber = 1;
  inline const ::FileInformation& fileinformation() const;
  inline ::FileInformation* mutable_fileinformation();
  inline ::FileInformation* release_fileinformation();
  inline void set_allocated_fileinformation(::FileInformation* fileinformation);

  // @@protoc_insertion_point(class_scope:TestConnectionResponse)
 private:
  inline void set_has_fileinformation();
  inline void clear_has_fileinformation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FileInformation* fileinformation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static TestConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddFolderResponse : public ::google::protobuf::Message {
 public:
  AddFolderResponse();
  virtual ~AddFolderResponse();

  AddFolderResponse(const AddFolderResponse& from);

  inline AddFolderResponse& operator=(const AddFolderResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddFolderResponse& default_instance();

  void Swap(AddFolderResponse* other);

  // implements Message ----------------------------------------------

  AddFolderResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddFolderResponse& from);
  void MergeFrom(const AddFolderResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .FileInformation fileInformation = 1;
  inline bool has_fileinformation() const;
  inline void clear_fileinformation();
  static const int kFileInformationFieldNumber = 1;
  inline const ::FileInformation& fileinformation() const;
  inline ::FileInformation* mutable_fileinformation();
  inline ::FileInformation* release_fileinformation();
  inline void set_allocated_fileinformation(::FileInformation* fileinformation);

  // @@protoc_insertion_point(class_scope:AddFolderResponse)
 private:
  inline void set_has_fileinformation();
  inline void clear_has_fileinformation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FileInformation* fileinformation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static AddFolderResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResourceResponse : public ::google::protobuf::Message {
 public:
  DeleteResourceResponse();
  virtual ~DeleteResourceResponse();

  DeleteResourceResponse(const DeleteResourceResponse& from);

  inline DeleteResourceResponse& operator=(const DeleteResourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResourceResponse& default_instance();

  void Swap(DeleteResourceResponse* other);

  // implements Message ----------------------------------------------

  DeleteResourceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteResourceResponse& from);
  void MergeFrom(const DeleteResourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .FileInformation fileInformation = 1;
  inline bool has_fileinformation() const;
  inline void clear_fileinformation();
  static const int kFileInformationFieldNumber = 1;
  inline const ::FileInformation& fileinformation() const;
  inline ::FileInformation* mutable_fileinformation();
  inline ::FileInformation* release_fileinformation();
  inline void set_allocated_fileinformation(::FileInformation* fileinformation);

  // @@protoc_insertion_point(class_scope:DeleteResourceResponse)
 private:
  inline void set_has_fileinformation();
  inline void clear_has_fileinformation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FileInformation* fileinformation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_response_2eproto();
  friend void protobuf_AssignDesc_response_2eproto();
  friend void protobuf_ShutdownFile_response_2eproto();

  void InitAsDefaultInstance();
  static DeleteResourceResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ResponsePacket

// optional .FolderStructureResponse folderStructureResponse = 1;
inline bool ResponsePacket::has_folderstructureresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponsePacket::set_has_folderstructureresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponsePacket::clear_has_folderstructureresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponsePacket::clear_folderstructureresponse() {
  if (folderstructureresponse_ != NULL) folderstructureresponse_->::FolderStructureResponse::Clear();
  clear_has_folderstructureresponse();
}
inline const ::FolderStructureResponse& ResponsePacket::folderstructureresponse() const {
  return folderstructureresponse_ != NULL ? *folderstructureresponse_ : *default_instance_->folderstructureresponse_;
}
inline ::FolderStructureResponse* ResponsePacket::mutable_folderstructureresponse() {
  set_has_folderstructureresponse();
  if (folderstructureresponse_ == NULL) folderstructureresponse_ = new ::FolderStructureResponse;
  return folderstructureresponse_;
}
inline ::FolderStructureResponse* ResponsePacket::release_folderstructureresponse() {
  clear_has_folderstructureresponse();
  ::FolderStructureResponse* temp = folderstructureresponse_;
  folderstructureresponse_ = NULL;
  return temp;
}
inline void ResponsePacket::set_allocated_folderstructureresponse(::FolderStructureResponse* folderstructureresponse) {
  delete folderstructureresponse_;
  folderstructureresponse_ = folderstructureresponse;
  if (folderstructureresponse) {
    set_has_folderstructureresponse();
  } else {
    clear_has_folderstructureresponse();
  }
}

// optional .DownloadInitResponse downloadInitResponse = 2;
inline bool ResponsePacket::has_downloadinitresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponsePacket::set_has_downloadinitresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponsePacket::clear_has_downloadinitresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponsePacket::clear_downloadinitresponse() {
  if (downloadinitresponse_ != NULL) downloadinitresponse_->::DownloadInitResponse::Clear();
  clear_has_downloadinitresponse();
}
inline const ::DownloadInitResponse& ResponsePacket::downloadinitresponse() const {
  return downloadinitresponse_ != NULL ? *downloadinitresponse_ : *default_instance_->downloadinitresponse_;
}
inline ::DownloadInitResponse* ResponsePacket::mutable_downloadinitresponse() {
  set_has_downloadinitresponse();
  if (downloadinitresponse_ == NULL) downloadinitresponse_ = new ::DownloadInitResponse;
  return downloadinitresponse_;
}
inline ::DownloadInitResponse* ResponsePacket::release_downloadinitresponse() {
  clear_has_downloadinitresponse();
  ::DownloadInitResponse* temp = downloadinitresponse_;
  downloadinitresponse_ = NULL;
  return temp;
}
inline void ResponsePacket::set_allocated_downloadinitresponse(::DownloadInitResponse* downloadinitresponse) {
  delete downloadinitresponse_;
  downloadinitresponse_ = downloadinitresponse;
  if (downloadinitresponse) {
    set_has_downloadinitresponse();
  } else {
    clear_has_downloadinitresponse();
  }
}

// optional .DownloadDataResponse downloadDataResponse = 3;
inline bool ResponsePacket::has_downloaddataresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponsePacket::set_has_downloaddataresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponsePacket::clear_has_downloaddataresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponsePacket::clear_downloaddataresponse() {
  if (downloaddataresponse_ != NULL) downloaddataresponse_->::DownloadDataResponse::Clear();
  clear_has_downloaddataresponse();
}
inline const ::DownloadDataResponse& ResponsePacket::downloaddataresponse() const {
  return downloaddataresponse_ != NULL ? *downloaddataresponse_ : *default_instance_->downloaddataresponse_;
}
inline ::DownloadDataResponse* ResponsePacket::mutable_downloaddataresponse() {
  set_has_downloaddataresponse();
  if (downloaddataresponse_ == NULL) downloaddataresponse_ = new ::DownloadDataResponse;
  return downloaddataresponse_;
}
inline ::DownloadDataResponse* ResponsePacket::release_downloaddataresponse() {
  clear_has_downloaddataresponse();
  ::DownloadDataResponse* temp = downloaddataresponse_;
  downloaddataresponse_ = NULL;
  return temp;
}
inline void ResponsePacket::set_allocated_downloaddataresponse(::DownloadDataResponse* downloaddataresponse) {
  delete downloaddataresponse_;
  downloaddataresponse_ = downloaddataresponse;
  if (downloaddataresponse) {
    set_has_downloaddataresponse();
  } else {
    clear_has_downloaddataresponse();
  }
}

// optional .TestConnectionResponse testConnectionResponse = 4;
inline bool ResponsePacket::has_testconnectionresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponsePacket::set_has_testconnectionresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponsePacket::clear_has_testconnectionresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponsePacket::clear_testconnectionresponse() {
  if (testconnectionresponse_ != NULL) testconnectionresponse_->::TestConnectionResponse::Clear();
  clear_has_testconnectionresponse();
}
inline const ::TestConnectionResponse& ResponsePacket::testconnectionresponse() const {
  return testconnectionresponse_ != NULL ? *testconnectionresponse_ : *default_instance_->testconnectionresponse_;
}
inline ::TestConnectionResponse* ResponsePacket::mutable_testconnectionresponse() {
  set_has_testconnectionresponse();
  if (testconnectionresponse_ == NULL) testconnectionresponse_ = new ::TestConnectionResponse;
  return testconnectionresponse_;
}
inline ::TestConnectionResponse* ResponsePacket::release_testconnectionresponse() {
  clear_has_testconnectionresponse();
  ::TestConnectionResponse* temp = testconnectionresponse_;
  testconnectionresponse_ = NULL;
  return temp;
}
inline void ResponsePacket::set_allocated_testconnectionresponse(::TestConnectionResponse* testconnectionresponse) {
  delete testconnectionresponse_;
  testconnectionresponse_ = testconnectionresponse;
  if (testconnectionresponse) {
    set_has_testconnectionresponse();
  } else {
    clear_has_testconnectionresponse();
  }
}

// optional .AddFolderResponse addFolderResponse = 5;
inline bool ResponsePacket::has_addfolderresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponsePacket::set_has_addfolderresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponsePacket::clear_has_addfolderresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponsePacket::clear_addfolderresponse() {
  if (addfolderresponse_ != NULL) addfolderresponse_->::AddFolderResponse::Clear();
  clear_has_addfolderresponse();
}
inline const ::AddFolderResponse& ResponsePacket::addfolderresponse() const {
  return addfolderresponse_ != NULL ? *addfolderresponse_ : *default_instance_->addfolderresponse_;
}
inline ::AddFolderResponse* ResponsePacket::mutable_addfolderresponse() {
  set_has_addfolderresponse();
  if (addfolderresponse_ == NULL) addfolderresponse_ = new ::AddFolderResponse;
  return addfolderresponse_;
}
inline ::AddFolderResponse* ResponsePacket::release_addfolderresponse() {
  clear_has_addfolderresponse();
  ::AddFolderResponse* temp = addfolderresponse_;
  addfolderresponse_ = NULL;
  return temp;
}
inline void ResponsePacket::set_allocated_addfolderresponse(::AddFolderResponse* addfolderresponse) {
  delete addfolderresponse_;
  addfolderresponse_ = addfolderresponse;
  if (addfolderresponse) {
    set_has_addfolderresponse();
  } else {
    clear_has_addfolderresponse();
  }
}

// optional .DeleteResourceResponse deleteResourceResponse = 6;
inline bool ResponsePacket::has_deleteresourceresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponsePacket::set_has_deleteresourceresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponsePacket::clear_has_deleteresourceresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponsePacket::clear_deleteresourceresponse() {
  if (deleteresourceresponse_ != NULL) deleteresourceresponse_->::DeleteResourceResponse::Clear();
  clear_has_deleteresourceresponse();
}
inline const ::DeleteResourceResponse& ResponsePacket::deleteresourceresponse() const {
  return deleteresourceresponse_ != NULL ? *deleteresourceresponse_ : *default_instance_->deleteresourceresponse_;
}
inline ::DeleteResourceResponse* ResponsePacket::mutable_deleteresourceresponse() {
  set_has_deleteresourceresponse();
  if (deleteresourceresponse_ == NULL) deleteresourceresponse_ = new ::DeleteResourceResponse;
  return deleteresourceresponse_;
}
inline ::DeleteResourceResponse* ResponsePacket::release_deleteresourceresponse() {
  clear_has_deleteresourceresponse();
  ::DeleteResourceResponse* temp = deleteresourceresponse_;
  deleteresourceresponse_ = NULL;
  return temp;
}
inline void ResponsePacket::set_allocated_deleteresourceresponse(::DeleteResourceResponse* deleteresourceresponse) {
  delete deleteresourceresponse_;
  deleteresourceresponse_ = deleteresourceresponse;
  if (deleteresourceresponse) {
    set_has_deleteresourceresponse();
  } else {
    clear_has_deleteresourceresponse();
  }
}

// -------------------------------------------------------------------

// FolderStructureResponse

// repeated .FileInformation fileInformation = 1;
inline int FolderStructureResponse::fileinformation_size() const {
  return fileinformation_.size();
}
inline void FolderStructureResponse::clear_fileinformation() {
  fileinformation_.Clear();
}
inline const ::FileInformation& FolderStructureResponse::fileinformation(int index) const {
  return fileinformation_.Get(index);
}
inline ::FileInformation* FolderStructureResponse::mutable_fileinformation(int index) {
  return fileinformation_.Mutable(index);
}
inline ::FileInformation* FolderStructureResponse::add_fileinformation() {
  return fileinformation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FileInformation >&
FolderStructureResponse::fileinformation() const {
  return fileinformation_;
}
inline ::google::protobuf::RepeatedPtrField< ::FileInformation >*
FolderStructureResponse::mutable_fileinformation() {
  return &fileinformation_;
}

// -------------------------------------------------------------------

// FileInformation

// optional string name = 1;
inline bool FileInformation::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileInformation::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileInformation::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileInformation::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FileInformation::name() const {
  return *name_;
}
inline void FileInformation::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileInformation::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FileInformation::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FileInformation::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FileInformation::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FileInformation::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 resourceType = 2;
inline bool FileInformation::has_resourcetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileInformation::set_has_resourcetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileInformation::clear_has_resourcetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileInformation::clear_resourcetype() {
  resourcetype_ = 0u;
  clear_has_resourcetype();
}
inline ::google::protobuf::uint32 FileInformation::resourcetype() const {
  return resourcetype_;
}
inline void FileInformation::set_resourcetype(::google::protobuf::uint32 value) {
  set_has_resourcetype();
  resourcetype_ = value;
}

// optional uint64 size = 3;
inline bool FileInformation::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileInformation::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileInformation::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileInformation::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 FileInformation::size() const {
  return size_;
}
inline void FileInformation::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// optional uint64 createTime = 4;
inline bool FileInformation::has_createtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FileInformation::set_has_createtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FileInformation::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FileInformation::clear_createtime() {
  createtime_ = GOOGLE_ULONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::uint64 FileInformation::createtime() const {
  return createtime_;
}
inline void FileInformation::set_createtime(::google::protobuf::uint64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint64 modifiedTime = 5;
inline bool FileInformation::has_modifiedtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FileInformation::set_has_modifiedtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FileInformation::clear_has_modifiedtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FileInformation::clear_modifiedtime() {
  modifiedtime_ = GOOGLE_ULONGLONG(0);
  clear_has_modifiedtime();
}
inline ::google::protobuf::uint64 FileInformation::modifiedtime() const {
  return modifiedtime_;
}
inline void FileInformation::set_modifiedtime(::google::protobuf::uint64 value) {
  set_has_modifiedtime();
  modifiedtime_ = value;
}

// optional bool isDirectory = 6;
inline bool FileInformation::has_isdirectory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FileInformation::set_has_isdirectory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FileInformation::clear_has_isdirectory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FileInformation::clear_isdirectory() {
  isdirectory_ = false;
  clear_has_isdirectory();
}
inline bool FileInformation::isdirectory() const {
  return isdirectory_;
}
inline void FileInformation::set_isdirectory(bool value) {
  set_has_isdirectory();
  isdirectory_ = value;
}

// -------------------------------------------------------------------

// DownloadInitResponse

// required .FileInformation fileInformation = 1;
inline bool DownloadInitResponse::has_fileinformation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadInitResponse::set_has_fileinformation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadInitResponse::clear_has_fileinformation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadInitResponse::clear_fileinformation() {
  if (fileinformation_ != NULL) fileinformation_->::FileInformation::Clear();
  clear_has_fileinformation();
}
inline const ::FileInformation& DownloadInitResponse::fileinformation() const {
  return fileinformation_ != NULL ? *fileinformation_ : *default_instance_->fileinformation_;
}
inline ::FileInformation* DownloadInitResponse::mutable_fileinformation() {
  set_has_fileinformation();
  if (fileinformation_ == NULL) fileinformation_ = new ::FileInformation;
  return fileinformation_;
}
inline ::FileInformation* DownloadInitResponse::release_fileinformation() {
  clear_has_fileinformation();
  ::FileInformation* temp = fileinformation_;
  fileinformation_ = NULL;
  return temp;
}
inline void DownloadInitResponse::set_allocated_fileinformation(::FileInformation* fileinformation) {
  delete fileinformation_;
  fileinformation_ = fileinformation;
  if (fileinformation) {
    set_has_fileinformation();
  } else {
    clear_has_fileinformation();
  }
}

// -------------------------------------------------------------------

// DownloadDataResponse

// required bytes data = 1;
inline bool DownloadDataResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DownloadDataResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DownloadDataResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DownloadDataResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& DownloadDataResponse::data() const {
  return *data_;
}
inline void DownloadDataResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void DownloadDataResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void DownloadDataResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DownloadDataResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* DownloadDataResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DownloadDataResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestConnectionResponse

// required .FileInformation fileInformation = 1;
inline bool TestConnectionResponse::has_fileinformation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConnectionResponse::set_has_fileinformation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConnectionResponse::clear_has_fileinformation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConnectionResponse::clear_fileinformation() {
  if (fileinformation_ != NULL) fileinformation_->::FileInformation::Clear();
  clear_has_fileinformation();
}
inline const ::FileInformation& TestConnectionResponse::fileinformation() const {
  return fileinformation_ != NULL ? *fileinformation_ : *default_instance_->fileinformation_;
}
inline ::FileInformation* TestConnectionResponse::mutable_fileinformation() {
  set_has_fileinformation();
  if (fileinformation_ == NULL) fileinformation_ = new ::FileInformation;
  return fileinformation_;
}
inline ::FileInformation* TestConnectionResponse::release_fileinformation() {
  clear_has_fileinformation();
  ::FileInformation* temp = fileinformation_;
  fileinformation_ = NULL;
  return temp;
}
inline void TestConnectionResponse::set_allocated_fileinformation(::FileInformation* fileinformation) {
  delete fileinformation_;
  fileinformation_ = fileinformation;
  if (fileinformation) {
    set_has_fileinformation();
  } else {
    clear_has_fileinformation();
  }
}

// -------------------------------------------------------------------

// AddFolderResponse

// required .FileInformation fileInformation = 1;
inline bool AddFolderResponse::has_fileinformation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddFolderResponse::set_has_fileinformation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddFolderResponse::clear_has_fileinformation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddFolderResponse::clear_fileinformation() {
  if (fileinformation_ != NULL) fileinformation_->::FileInformation::Clear();
  clear_has_fileinformation();
}
inline const ::FileInformation& AddFolderResponse::fileinformation() const {
  return fileinformation_ != NULL ? *fileinformation_ : *default_instance_->fileinformation_;
}
inline ::FileInformation* AddFolderResponse::mutable_fileinformation() {
  set_has_fileinformation();
  if (fileinformation_ == NULL) fileinformation_ = new ::FileInformation;
  return fileinformation_;
}
inline ::FileInformation* AddFolderResponse::release_fileinformation() {
  clear_has_fileinformation();
  ::FileInformation* temp = fileinformation_;
  fileinformation_ = NULL;
  return temp;
}
inline void AddFolderResponse::set_allocated_fileinformation(::FileInformation* fileinformation) {
  delete fileinformation_;
  fileinformation_ = fileinformation;
  if (fileinformation) {
    set_has_fileinformation();
  } else {
    clear_has_fileinformation();
  }
}

// -------------------------------------------------------------------

// DeleteResourceResponse

// required .FileInformation fileInformation = 1;
inline bool DeleteResourceResponse::has_fileinformation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteResourceResponse::set_has_fileinformation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteResourceResponse::clear_has_fileinformation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteResourceResponse::clear_fileinformation() {
  if (fileinformation_ != NULL) fileinformation_->::FileInformation::Clear();
  clear_has_fileinformation();
}
inline const ::FileInformation& DeleteResourceResponse::fileinformation() const {
  return fileinformation_ != NULL ? *fileinformation_ : *default_instance_->fileinformation_;
}
inline ::FileInformation* DeleteResourceResponse::mutable_fileinformation() {
  set_has_fileinformation();
  if (fileinformation_ == NULL) fileinformation_ = new ::FileInformation;
  return fileinformation_;
}
inline ::FileInformation* DeleteResourceResponse::release_fileinformation() {
  clear_has_fileinformation();
  ::FileInformation* temp = fileinformation_;
  fileinformation_ = NULL;
  return temp;
}
inline void DeleteResourceResponse::set_allocated_fileinformation(::FileInformation* fileinformation) {
  delete fileinformation_;
  fileinformation_ = fileinformation;
  if (fileinformation) {
    set_has_fileinformation();
  } else {
    clear_has_fileinformation();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_response_2eproto__INCLUDED
